**1、MySQL 中有哪几种锁？** 

1、表级锁： 开销小， 加锁快； 不会出现死锁； 锁定粒度大， 发生锁冲突的概率最高， 

并发度最低。 

2、行级锁： 开销大， 加锁慢； 会出现死锁； 锁定粒度最小， 发生锁冲突的概率最低， 

并发度也最高。 

3、页面锁： 开销和加锁时间界于表锁和行锁之间； 会出现死锁； 锁定粒度界于表锁和 

行锁之间， 并发度一般。 

**2、MySQL 中有哪些不同的表格？** 

共有 5 种类型的表格： 

1、MyISAM 

2、Heap 

3、Merge 

4、INNODB 

5、ISAM 

**3、简述在MySQL 数据库中 MyISAM 和InnoDB 的区别** 

**MyISAM：** 

不支持事务， 但是每次查询都是原子的； 支持表级锁， 即每次操作是对整个表加锁； 

存储表的总行数； 

一个 MYISAM 表有三个文件： 索引文件、表结构文件、数据文件； 

采用非聚集索引， 索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致， 

但是辅索引不用保证唯一性。 

**InnoDb：** 

支持 ACID 的事务， 支持事务的四种隔离级别； 支持行级锁及外键约束： 因此可以支持写并发； 

**不存储总行数：**

一个 InnoDb 引擎存储在一个文件空间（ 共享表空间， 表大小不受操作系统控制， 一个 表可能分布在多个文件里）， 也有可能为多个（ 设置为独立表空， 表大小受操作系统文件 大小限制， 一般为 2G）， 受操作系统文件大小的限制； 

主键索引采用聚集索引（ 索引的数据域存储数据文件本身）， 辅索引的数据域存储主键 的值； 因此从辅索引查找数据， 需要先通过辅索引找到主键值， 再访问辅索引； 最好使 用自增主键， 防止插入数据时， 为维持 B+树结构， 文件的大调整。



**4、MySQL 中InnoDB 支持的四种事务隔离级别名称，以及逐** **级之间的区别？** 

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

### 幻读(phantom read)

- **前提条件**：InnoDB引擎，可重复读隔离级别，使用**当前读**时。
- **表现**：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。**两点需要说明**：
   　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在**当前读**下才会出现。
      　2、幻读专指**新插入的行**，读到原本存在行的更新结果不算。因为**当前读**的作用就是能读到所有已经提交记录的最新值。

### 幻读的影响

- 会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。
- 产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。

### 幻读产生的原因

- 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。

### 如何解决幻读

- 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为**间隙锁**。
- 间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是**往这个间隙中插入一个记录**这个操作。

------

**6、主键和候选键有什么区别？** 

表格的每一行都由主键唯一标识,一个表只有一个主键。 

主键也是候选键。按照惯例， 候选键可以被指定为主键， 并且可以用于任何外键引用。

 

**7、myisamchk 是用来做什么的？** 

它用来压缩 MyISAM 表， 这减少了磁盘或内存使用。 



**MyISAM Static 和 MyISAM Dynamic 有什么区别？** 

在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT， BLOB 

等字段， 以适应不同长度的数据类型。 

MyISAM Static 在受损情况下更容易恢复。 



**8、如果一个表有一列定义为TIMESTAMP，将发生什么？** 

每当行被更改时， 时间戳字段将获取当前时间戳。

 

**列设置为 AUTO INCREMENT 时， 如果在表中达到最大值， 会发生什么情况？** 

它会停止递增， 任何进一步的插入都将产生错误， 因为密钥已被使用。 

**怎样才能找出最后一次插入时分配了哪个自动增量？** 

LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值， 并且不需要指定表名 

称。

**9、你怎么看到为表格定义的所有索引？** 

索引是通过以下方式为表格定义的：

```
SHOW INDEX FROM <tablename>; 
```



**10、LIKE 声明中的％和_是什么意思？** 

％ 对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。 

**如何在 Unix 和 MySQL 时间戳之间进行转换？** 

UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令 

FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令 



**11、列对比运算符是什么？** 

在 SELECT 语句的列比较中使用=，<>，<=，<，> =，>，<<，>>，<=>，AND， 

OR 或 LIKE 运算符。 



**12、BLOB 和TEXT 有什么区别？** 

BLOB 是一个二进制对象， 可以容纳可变数量的数据。TEXT 是一个不区分大小写的 

BLOB。 

BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写， 对 

TEXT 值不区分大小写。 



**13、MySQL_fetch_array 和MySQL_fetch_object 的区别是** 

**什么？** 

以下是 MySQL_fetch_array 和 MySQL_fetch_object 的区别： 

MySQL_fetch_array（ ） – 将结果行作为关联数组或来自数据库的常规数组返回。 

MySQL_fetch_object – 从数据库返回结果行作为对象。 



**14、MyISAM 表格将在哪里存储，并且还提供其存储格式？** 

每个 MyISAM 表格以三种格式存储在磁盘上： 

·“.frm” 文件存储表定义 

·数据文件具有“.MYD”（MYData） 扩展名 

索引文件具有“.MYI” （MYIndex） 扩展名 

**15、MySQL 如何优化DISTINCT？** 

DISTINCT 在所有列上转换为 GROUP BY， 并与 ORDER BY 子句结合使用。 

```
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a; 
```



**16、如何显示前 50 行？** 

在 MySQL 中， 使用以下代码查询显示前 50 行： 

```
SELECT*FROM LIMIT 0,50; 
```

**17、可以使用多少列创建索引？** 

任何标准表最多可以创建 16 个索引列。 

**18、NOW（）和 CURRENT_DATE（）有什么区别？** 

NOW（） 命令用于显示当前年份， 月份， 日期， 小时， 分钟和秒。 

CURRENT_DATE（） 仅显示当前年份， 月份和日期。 

**19、什么是非标准字符串类型？** 

1、TINYTEXT 

2、TEXT 

3、MEDIUMTEXT 

4、LONGTEXT 



**20、什么是通用 SQL 函数？** 

1、CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个 

字段合并为一个字段。 

第 140 页 共 485 页2、FORMAT(X, D)- 格式化数字 X 到 D 有效数字。 

3、CURRDATE(), CURRTIME()- 返回当前日期或时间。 

4、NOW（） – 将当前日期和时间作为一个值返回。 

5、MONTH（）， DAY（ ）， YEAR（）， WEEK（）， WEEKDAY（） – 从日期值中 

提取给定数据。 

6、HOUR（）， MINUTE（）， SECOND（） – 从时间值中提取给定数据。 

7、DATEDIFF（ A， B） – 确定两个日期之间的差异， 通常用于计算年龄 

8、SUBTIMES（ A， B） – 确定两次之间的差异。 

9、FROMDAYS（ INT） – 将整数天数转换为日期值。 

**21、MySQL 支持事务吗？** 

在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时提交， 

所以在缺省情况下， MySQL 是不支持事务的。 

但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话， 你的MySQL 

就可以使用事务处理,使用 SET 

AUTOCOMMIT=0 就可以使 MySQL 允许在非 autocommit 模式， 在非 

autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回 

滚你的更改。 

 

**22、MySQL 里记录货币用什么字段类型好** 

NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型， 这在 SQL92 标准允许。 

他们被用于保存值， 该值的准确精度是极其重要的值， 例如与金钱有关的数据。当声明 

一个类是这些类型之一时， 精度和规模的能被(并且通常是)指定。 

例如： 

salary DECIMAL(9,2) 

在这个例子中， 9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被 

用于存储小数点后的位数。 

因此， 在这种情况下， 能被存储在 salary 列中的值的范围是从-9999999.99 到 

9999999.99。 



**23、MySQL 有关权限的表都有哪几个？** 

MySQL 服务器通过权限表来控制用户对数据库的访问， 权限表存放在 MySQL 数据 

库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv， 

columns_priv 和 host。 



**24、列的字符串类型可以是什么？** 

字符串类型是： 

1、SET2、BLOB 

3、ENUM 

4、CHAR 

5、TEXT 



**25、MySQL 数据库作发布系统的存储，一天五万条以上的增量，** 

**预计运维三年,怎么优化？** 

1、设计良好的数据库结构， 允许部分数据冗余， 尽量避免 join 查询， 提高效率。 

2、选择合适的表字段数据类型和存储引擎， 适当的添加索引。 

3、MySQL 库主从读写分离。 

4、找规律分表， 减少单表中的数据量提高查询速度。

5、 添加缓存机制， 比如 memcached， apc 等。 

6、不经常改动的页面， 生成静态页面。 

7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, 

field_2, field_3 FROM TABLE. 



**26、锁的优化策略** 

1、读写分离 

2、分段加锁 

3、减少锁持有的时间 

\4. 多个线程尽量以相同的顺序去获取资源 

不能将锁的粒度过于细化， 不然可能会出现线程的加锁和释放次数过多， 反而效率不如 

一次加一把大锁。 

**27、索引的底层实现原理和优化** 

B+树， 经过优化的 B+树 

主要是在所有的叶子结点中增加了指向下一个叶子节点的指针， 因此 InnoDB 建议为大 

部分表使用默认自增的主键作为主索引。 

**28、什么情况下设置了索引但无法使用** 

1、以“ %” 开头的 LIKE 语句， 模糊匹配 

2、OR 语句前后没有同时使用索引 

3、数据类型出现隐式转化（ 如 varchar 不加单引号的话可能会自动转换为 int 型） 

**29、实践中如何优化 MySQL** 

最好是按照以下顺序优化： 

1、SQL 语句及索引的优化 

2、数据库表结构的优化 

3、系统配置的优化 

4、硬件的优化 

详细可以查看 阿里 P8 架构师谈：MySQL 慢查询优化、索引优化、以及表等优化总 

结

**30、优化数据库的方法** 

1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例 

如’ 省份’ 、’ 性别’ 最好适用 ENUM 

2、使用连接(JOIN)来代替子查询 

3、适用联合(UNION)来代替手动创建的临时表 

4、事务处理 

5、锁定表、优化事务处理 

6、适用外键， 优化锁定表 

7、建立索引 

8、优化查询语句 



**31、简单描述 MySQL 中，索引，主键，唯一索引，联合索引** 

**的区别，对数据库的性能有什么影响（从读写两方面）** 

索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)， 它们包含着 

对数据表里所有记录的引用指针。 

普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。 

普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相 

同的值， 在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一 

索引。也就是说， 唯一索引可以保证数据记录的唯一性。 

主键， 是一种特殊的唯一索引， 在一张表中只能定义一个主键索引， 主键用于唯一标 

识一条记录， 使用关键字 PRIMARY KEY 来创建。 

索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。 

索引可以极大的提高数据的查询速度， 但是会降低插入、删除、更新表的速度， 因为在执行 

这些写操作时， 还要操作索引文件。 

**32、数据库中的事务是什么?** 

事务（transaction） 是作为一个单元的一组有序的数据库操作。如果组中的所有 

操作都成功， 则认为事务成功， 即使只有一个操作失败， 事务也不成功。如果所 

有操作完成， 事务则提交， 其修改将作用于所有其他数据库进程。如果一个操作失败， 

则事务将回滚， 该事务所有操作的影响都将取消。 

**事务特性：** 

1、原子性： 即不可分割性， 事务要么全部被执行， 要么就全部不被执行。 

2、一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状 态 

3、隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何 其他事 

务，

4、持久性。事务正确提交后， 其结果将永久保存在数据库中， 即使在事务提交后有了其 

他故障， 事务的处理结果也会得到保存。 

或者这样理解： 

事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组， 如果任何一个语句操作 

失败那么整个操作就被失败， 以后操作就会回滚到操作前状态， 或者是上有个节点。为 

了确保要么执行， 要么不执行， 就可以使用事务。要将有组语句作为事务考虑， 就需要 

通过 ACID 测试， 即原子性， 一致性， 隔离性和持久性。 

**33、SQL 注入漏洞产生的原因？如何防止？** 

SQL 注入产生的原因： 程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤， 

导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。 

防止 SQL 注入的方式： 

开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置 

执行 sql 语句时使用 addslashes 进行 sql 语句转换Sql 

语句书写尽量不要省略双引号和单引号。 

过滤掉 sql 语句中的一些关键词： update、insert、delete、select、 * 。 

提高数据库表和字段的命名技巧， 对一些重要的字段根据程序的特点命名， 取不易被猜 

到的。 

**34、为表中得字段选择合适得数据类型** 

字段类型优先级: 整形>date,time>enum,char>varchar>blob,text 

优先考虑数字类型， 其次是日期或者二进制类型， 最后是字符串类型， 同级别得数据 

类型， 应该优先选择占用空间小的数据类型 

**35、存储时期** 

Datatime:以 YYYY-MM-DD HH:MM:SS 格式存储时期时间， 精确到秒， 

占用 8 个字节得存储空间， datatime 类型与时区无关 

Timestamp:以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19， 显示 

依赖于所指定得时区， 默认在第一个列行的数据修改时可以自动得修改 

timestamp 列得值 

Date:（ 生日） 占用得字节数比使用字符串.datatime.int 储存要少， 使用 date 只需要 3 

个字节， 存储日期月份， 还可以利用日期时间函数进行日期间得计算 

Time:存储时间部分得数据 

注意:不要使用字符串类型来存储日期时间数据（ 通常比字符串占用得储存空间小， 在进行查找 

过滤可以利用日期得函数） 

使用 int 存储日期时间不如使用 timestamp 类型 

**36、对于关系型数据库而言，索引是相当重要的概念，请回答** 

**有关索引的几个问题：** 

1、索引的目的是什么？ 

快速访问数据表中的特定信息， 提高检索速度 

创建唯一性索引， 保证数据库表中每一行数据的唯一性。加速 表和表之间的连接 

使用分组和排序子句进行数据检索时， 可以显著减少查询中分组和排序的时间2、索引对 

数据库系统的负面影响是什么？ 

负面影响： 

创建索引和维护索引需要耗费时间， 这个时间随着数据量的增加而增加； 索引需要占用 

物理空间， 不光是表需要占用数据空间， 每个索引也需要占用物理空间； 当对表进行 

增、删、改、的时候索引也要动态维护， 这样就降低了数据的维护速度。 

3、为数据表建立索引的原则有哪些？ 

在最频繁使用的、用以缩小查询范围的字段上建立索引。 

在频繁使用的、需要排序的字段上建立索引 

4、什么情况下不宜建立索引？ 

第 149 页 共 485 页对于查询中很少涉及的列或者重复值比较多的列， 不宜建立索引。对 

于一些特殊的数据类型， 不宜建立索引， 比如文本字段（ text） 等 

**37、解释 MySQL 外连接、内连接与自连接的区别** 

先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的 

所有记录和另一个表中的所有记录一一匹配。 

内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记 

录不会出现在结果集中， 即内连接只连接匹配的行。 

外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中 

的所有数据行， 这三种情况依次称之为左外连接， 右外连接， 和全外连接。 

左外连接， 也称左连接， 左表为主表， 左表中的所有记录都会出现在结果集中， 对于那 

些在右表中并没有匹配的记录， 仍然要显示， 右边对应的那些字段值以NULL 来填充。 

右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和 

右连接可以互换， MySQL 目前还不支持全外连接。 

**38、Myql 中的事务回滚机制概述** 

事务是用户定义的一个数据库操作序列， 这些操作要么全做要么全不做， 是一个不可分 

割的工作单位， 事务回滚是指将该事务已经完成的对数据库的更新操作撤销。 

要同时修改数据库中两个不同表时， 如果它们不是一个事务的话， 当第一个表修改完， 

可能第二个表修改过程中出现了异常而没能修改， 此时就只有第二个表依旧是未修改之 

前的状态， 而第一个表已经被修改完毕。而当你把它们设定为一个 

事务的时候， 当第一个表修改完， 第二表修改出现异常而没能修改， 第一个表和第二 

个表都要回到未修改的状态， 这就是所谓的事务回滚 

**39、SQL 语言包括哪几部分？每部分都有哪些操作关键字？** 

SQL 语言包括数据定义(DDL)、数据操纵(DML),数据控制(DCL)和数据查询（ DQL） 

四个部分。 

数据定义： Create Table,Alter Table,Drop Table, Craete/Drop Index 等数据操 

纵： Select ,insert,update,delete, 

数据控制： grant,revoke 

数据查询： select 

**40、完整性约束包括哪些？** 

数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。 

**分为以下四类：** 

1、实体完整性： 规定表的每一行在表中是惟一的实体。 

2、域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括 取值范 

围、精度等规定。 

3、参照完整性： 是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一 

致性， 防止了数据丢失或无意义的数据在数据库中扩散。 

第 151 页 共 485 页4、用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需 要一些特 

殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件， 它反映某一 

具体应用必须满足的语义要求。 

与表有关的约束：包括列约束(NOT NULL（ 非空约束）)和表约束(PRIMARY KEY、 

foreign key、check、UNIQUE) 。 

**41、什么是锁？** 

答： 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时， 在数据库中 

就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可 能会读取和存储 

不正确的数据， 破坏数据库的一致性。 

加 锁 是 实 现 数 据 库 并 发 控 制 的 一 个 非 常 重 要 的 技 术 。 当 事 务 在 对 某 个 数 据 对 象 进 

行操作前， 先向系统发出请求， 对其加锁。加锁后事务就对该数据对象有了一定的 

控制， 在该事务释放锁之前， 其他的事务不能对此数据对象进行更新操作。 

**基本锁类型： 锁包括行级锁和表级锁** 

**42、什么叫视图？游标是什么？** 

答： 视图是一种虚拟的表， 具有和物理表相同的功能。可以对视图进行增， 改， 查， 

操作， 视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。 

它使得我们获取数据更容易， 相比多表查询。 

游标： 是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定 

行， 从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标， 

但是需要逐条处理数据的时候， 游标显得十分重要。 

**43、什么是存储过程？用什么来调用？** 

答： 存储过程是一个预编译的 SQL 语句， 优点是允许模块化的设计， 就是说只需创建 

一次， 以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL， 使用存储过 

程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。 

**44、如何通俗地理解三个范式？** 

答：第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解； 第二范 

式：2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性； 

第三范式： 3NF 是对字段冗余性的约束， 即任何字段不能由其他字段派生出来， 

它要求字段没有冗余。。 

**范式化设计优缺点:** 

**优点:** 

可以尽量得减少数据冗余， 使得更新快， 体积小 

缺点:对于查询需要多个表进行关联， 减少写得效率增加读得效率， 更难进行索引优化 

**反范式化:** 

优点:可以减少表得关联， 可以更好得进行索引优化 

缺点:数据冗余以及数据异常， 数据得修改需要更多的成本 



**45、什么是基本表？什么是视图？** 

答：基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。 视图是从一个或几 

个基本表导出的表。视图本身不独立存储在数据库中， 是一个虚表 



**46、试述视图的优点？** 

答：(1) 视图能够简化用户的操作 (2) 视图使用户能以多种角度看待同一数据； 

(3) 视图为数据库提供了一定程度的逻辑独立性； (4) 视图能够对机密数据提供安全保 

护。

**47、 NULL 是什么意思** 

答： NULL 这个值表示 UNKNOWN(未知):它不表示“” (空字符串)。对 NULL 这个值的 

任何比较都会生产一个 NULL 值。您不能把任何值与一个 NULL 值进行比较， 并在逻辑 

上希望获得一个答案。 

使用 IS NULL 来进行 NULL 判断 

**48、主键、外键和索引的区别？** 

主键、外键和索引的区别 

**定义：** 

主键– 唯一标识一条记录， 不能有重复的， 不允许为空 

外键– 表的外键是另一表的主键, 外键可以有重复的, 可以是空值索引– 

该字段没有重复值， 但可以有一个空值 

**作用：** 

主键– 用来保证数据完整性 

外键– 用来和其他表建立联系用的索 

引– 是提高查询排序的速度 

**个数：** 

主键– 主键只能有一个 

外键– 一个表可以有多个外键 

索引– 一个表可以有多个唯一索引 

**49、你可以用什么来确保表格里的字段只接受特定范围里的值?** 

答： Check 限制， 它在数据库表格里被定义， 用来限制输入该列的值。 

触发器也可以被用来限制数据库表格里的字段能够接受的值， 但是这种办法要求触发器在表 

格里被定义， 这可能会在某些情况下影响到性能。 



**50、说说对 SQL 语句优化有哪些方法？（选择几条）** 

1、Where 子句中：where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤 

掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。 

2、用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。 

3、 避免在索引列上使用计算 

4、避免在索引列上使用 IS NULL 和 IS NOT NULL 

5、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列 

上建立索引。 

6、应尽量避免在 where 子句中对字段进行 null 值判断， 否则将导致引擎放弃使用索引 

而进行全表扫描 

7、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进 

行全表扫描 

------

### 索引的优缺点

**优点：**

1.大大加快数据的查询速度

2.唯一索引可以保证数据库表每一行的唯一性

3.加速表连接时间

**缺点：**

1.创建、维护索引要耗费时间，所以，索引数量不能过多。

2.索引是一种数据结构，会占据磁盘空间。

3.对表进行更新操作时，索引也要动态维护，降低了维护速度

### 索引的类型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。这里介绍三种常用于索引的数据结构，分别是哈希表、有序数组和搜索树。

#### 哈希索引

哈希表，也称散列表，主要设计思想是通过一个哈希函数， 把关键码映射的位置去寻找存放值的地方 ，读取的时候也是直接通过关键码来找到位置并存进去，这种数据结构的平均查找复杂度为O(1)。

比如我们维护一张身份证信息和用户姓名的表，需要根据身份证号查询姓名，哈希索引大概是这样的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8tYtyfejG8ydiaibl7seibWuoNsicL5rfwOSUkQa2CEicu6k11n6btwmt8vSw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



这种索引结构优点在于随机添加或删除单个元素的效率高，缺点在于哈希表中的元素并不一定按顺序排列，所以如果想做区间查询的话是很慢的，

假设我想查找图中身份证号在[ID_card_n1, ID_card_n3]这个区间的所有用户的话，就必须全部扫描一遍了。

所以，**哈希表这种结构适用于只有等值查询的场景**

#### 有序数组索引

有序数组索引在等值查询和区间查询场景中的效率都很高，还是拿上面的图做例子，用有序数组实现的话是这样子的：

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8ttK17Z3icEIibd3mAGzticmjImWXylwWhrgrlWI9ib85oREjQKico9OkHI3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



数组的元素按身份证号有序排列，要查询数据的时候，使用二分法就可以快速得到，时间复杂度为O(logN)，而且，因为是有序排列，查询某个区间内的数据也是非常的快。

当然，有序数组的缺点也很明显，就跟ArrayList一样，虽然搜索快，但添加删除元素都有可能要移动后面所有的元素，这是数组的天然缺陷。所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

#### 搜索树索引

说到搜索树，我们最熟悉的应该就是二叉搜索树了，二叉搜索树的特点是每个结点的左儿子小于父结点，父结点又小于右儿子，并且左右子树也分别为二叉搜索树，平均时间复杂度是O(log2(n))。

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8tj3PgtCw5qMib6nia0OKYBad4Fw7LsrXL9uu6DoWp9ibib6D9egtFOL7HEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势，同时，因为本身二叉搜索树是有序的，所以也支持范围查找

这么说起来，其实二叉搜索树来做索引好像也是个不错的选择，其实不然

首先我们要明确的一点是，这棵树是存在于磁盘中，每次我们都要从磁盘中读取出相应的结点，然而二叉搜索树的结点在文件中是随机存放的，所以可能读取一个结点就需要一个磁盘IO，恰恰二叉搜索树都会比较高，如一棵一百万个元素的平衡二叉树就有十几层高度了，也就是大部分情况下检索一次数据就需要十几次磁盘IO，这个代价太高了，所以一般二叉搜索树也不会被用来作索引。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块，也就是说，尽可能的让树的高度变低，也就是用多路搜索树，而InnoDB存储引擎使用的就是这种多路搜索树，也就是我们常说的B+树。

### InnoDB的索引结构

InnoDB是MySQL中最常用的搜索引擎，它的索引底层结构用的就是B+树，所有的数据都是存储在B+树中的。每一个索引在InnoDB中对应一颗B+树。

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8tr1ZiazZkOO87LUHhnrRnsc4bIAk7bFl0DHw825KU0zZ4kx4VOMbMbIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



B+树的特点是：

- 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的中间结点元素都同时存在于子结点，在子结点元素中是最大（或最小）元素。

这种结构有两个优点：

- 可以使得单一结点存储更多的元素，除了叶子结点，其他的结点只是包含了键，没有保存值，这样的话，树的高度就能有效降低，从而减少查询的IO次数；
- 同时，因为叶子结点包含了下个叶子结点的指针，所以范围查询的时候如果搜索到第一个叶子结点的话，就能根据指针指向查询后面的数据，不用再从根结点遍历了。这也是为什么很多大神建议表的主键设计成自增长的好，因为这样范围查询能提高效率

### 索引的分类

按照结构来分的话，数据库索引可以分为聚簇索引和非聚簇索引。

聚簇索引，也叫聚集索引，就是按照每张表的主键构造一颗B+树，同时叶子结点中存放的就是整张表的行记录数据，简单点说，就是我们常说的主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。

非聚簇索引，也叫非聚集索引，二级索引。这种索引是将数据与索引分开存储，索引结构的叶子结点指向了数据对应的位置。

#### 聚簇索引

InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，我们先假设一张用户表，这张表包含了id，name，company几个字段，

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8t8nKNSvJv3yVUQyWaOCf5EgKvZsmib0oexiaC9DnPZQichPxicMrApqLGbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



用图片表示InnoDB的索引结构大概是这样：

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8txLFibJ7ianEywslibddzkWia7Q3PwEQMlz6Xu8eOFpFnFjD2yf6ZjibrS7A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



从图中就可以看出，如果我们使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶结点，之后获得行数据。

若对Name列进行条件搜索，则需要两个步骤：

第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。

第二步使用主键在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据**。（**重点在于通过其他键需要建立辅助索引）

这是聚簇索引的结构，而非聚簇索引的代表是MyISM，这也是MySQL中常见的搜索引擎。

#### 非聚簇索引

非聚簇索引的两棵B+树看上去没什么不同，结点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。索引本身不存储数据，数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据。

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8t4xoRY7ehtx1ic6SiaxlNwwuRCictK7HjbTK5F6ibhia5St4aicuy5mWmCYLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



看上去，好像非聚簇索引的效率要高于聚簇索引，因为不用查两次B+树，那为什么最常用的InnoDB引擎还要用这种存储结构呢？它本身的优势在哪？

1、聚簇索引中，由于行数据和叶子结点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，所以，如果按照主键Id来组织数据，获得数据更快。

2、辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作**，**使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"**。**也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），**使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。**

3、聚簇索引适合用在排序、范围查询，非聚簇索引不适合。

### 覆盖索引

说到辅助索引，我们还可以延伸出另一种特别的索引，就是**覆盖索引**。

上面说了，聚簇索引中访问数据要经过二次查找，就是先找到辅助键的叶子结点，得到主键对应的结点后再用主键索引查询数据，这样还是比较慢的，其实，如果我们所需的字段第一次查找就能获取到的话，就不用再二次查找主键了，也就是不用“回表”。

就还是上面那张表有三个字段id，name，company的表来说，我给**name**加了索引，在查询数据的时候，我就这么写语句：

```
select name from user where name like '张%';
```

因为我们的语句走了索引，并且返回的字段在叶子结点都存在，查询的时候就不会回表了，多好啊~~

所以，如果所需的字段刚好是索引列的话，尽量用这种查询方式，不要用`select *`这种语句。

### 索引种类

前面说的索引分类是按照结构来分，如果按作用范围来分的话，索引还可以分为以下几种：

**普通索引**：这是最基本的索引类型，没唯一性之类的限制。

```
CREATE INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**唯一性索引**：和普通索引基本相同，但所有的索引列只能出现一次，保持唯一性。

```
CREATE UNIQUE INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**主键**：跟唯一索引一样，不能有重复的列，但本质上，主键不能算是索引，而是一种约束，必须指定为"PRIMARY KEY"。它跟唯一索引的区别在于：

- 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
- 唯一性索引列允许空值，而主键列不允许为空值。
- 主键列在创建时，已经默认为空值 + 唯一索引了。
- 主键可以被其他表引用为外键，而唯一索引不能。
- 一个表最多只能创建一个主键，但可以创建多个唯一索引。
- 主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。

**全文索引**：全文索引的索引类型为FULLTEXT，可以在VARCHAR或者TEXT类型的列上创建。在MySQL5.6以前的版本，只有 MyISAM 存储引擎支持全文索引，5.6及之后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。

```
CREATE FULLTEXT INDEX INDEX_NAME ON TABLE_NAME(PROPERTY_NAME)
```

**联合索引**：联合索引其实不是一种索引分类，就是包含多个字段的普通索引，比如有个联合索引为index(a，b)，查找的时候可以用 `a and b` 作为条件，

### 最左匹配原则

联合索引中，最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

就像上面说的index(a，b)或者是a单独作为查询条件都会走索引，但是如果是单独用 b 做查询条件就不会走索引了

或者是如果建立(a,b,c,d)顺序的索引的话，用a = 1 and b = 2 and c > 3 and d = 4这样的语句搜索，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。

### 索引什么时候会失效

1、索引列用函数或表达式，比如这种

```
select * from test where  num  +  1 = 5
```

MySQL无法解析这种方程，这完全是用户的行为，应该把索引列当成独立的列，这样索引才会生效。

2、存在NULL值条件

```
select * from user where user_id is not null;
```

我们在设计数据库表时，应该尽力避免NULL值出现，如果数据有为空的情况可以给一个默认值，比如数值型的可以给0、-1，字符类型的可以给空字符串。

3、用or表达式作为条件，有一个列没有索引，那么其它列的索引将不起作用

```
select * from user where user_id = 700 or user_name = "老薛";
```

像这种，如果user_id有加索引，而user_name没有的话，那么执行的时候user_id的索引也是失效的，这也是为什么开发中尽量少用or的原因，除非是两个字段都加了索引。

4、列与列对比，某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引

```
select * from test where id = c_id;
```

5、数据类型的转换。如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引

```
create index `idx_user_name` ON user(user_name)
select * from user where user_name = 123;
```

像上面这种，虽然给user_name建立了索引，但查询的时候条件没有当成字符串，这样的话就不会走索引。

6、NOT条件

当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：<>、NOT、in、not exists

```
select * from user where user_id<>500;
select * from user where user_id in (1,2,3,4,5);
select * from user where user_id not in (6,7,8,9,0);
select * from user where user_id exists (select 1 from user_record where user_record.user_id = user.user_id);
```

7、like查询是以%开头

当使用模糊搜索时，尽量采用后置的通配符，例如要查姓张的人，可以用`user_name like ‘张%’`，这样走索引时，可以从前面开始匹配索引列，但如果是这样`user_name like ‘%张’`，那么就会走全表扫描的方式

8、多列索引，遵循最左匹配原则，这个上面说了

### 什么时候该用索引

前面说了，索引虽然能加快查询速度，但本身也会占用空间，所以，索引的创建并不是越多越好，为了使索引能有效应用，我们要把索引留给最有用的查询字段，一般来说，应该在这些字段上创建索引：

- 主键字段，这不用多说了吧；
- 经常需要搜索的列，比如where条件经常用到的字段；
- 其他表的外键字段，作为连接表的条件字段，可以有效加快连表查询速度；
- 查询中作为排序、统计或者是分组的字段；

同样，对于有些字段不应该创建索引，这些列包括

- 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件
- where条件里用不到的字段，不创建索引；
- 表记录太少，不需要创建索引；
- 对于那些定义为text，image类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少，不利于使用索引；
- 数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，这种字段建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。

### explain关键字

explain是MySQL的关键字，通过该关键字我们可以查看搜索语句的性能。

![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)



这是查询表的数量，一共有三千多万行，这么多的数据，我们搜索的时候肯定要用到索引才行，至于索引是否会生效，我们也可以通过该关键字来看下，

![图片](https://mmbiz.qpic.cn/mmbiz_png/pCsDvfQo2sanMNnRCgIcXV7icmpKQFW8tE6IpQicQF6U0UERdQMWyreXeLicJZDVEJzvDjgzPkiayToHibLhWSL8iakQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

看，搜索的条数瞬间降到了16条，走的索引是 `index_user_id`，证明我们的索引是生效的。

关于explain的几个重要参数，我们有必要了解一些：

**id**：查询的序列号

**select_type**：查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。

**type**：

type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：

system > const > eq_ref > ref >fulltext > ref_or_null > index_merge > unique_subquery >index_subquery > range > index > ALL

System效率最高，ALL的话已经是全表扫描了，一般来说，查询至少要达到range级别。

**key**：

显示MySQL实际决定使用的键。如果没有索引被选择，键是NULL。

```
key=primary的话，表示使用了主键；

key=null表示没用到索引。
```

**possible_keys**：

指出MySQL能使用哪个索引在该表中找到行。如果是空的，没有相关的索引。这时要检查语句中是不是有什么情况导致索引失效。

**rows**：

表示执行计划中估计扫描的行数，是个估计值。

**Extra**：

- 如果是Only index，这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。
- 如果是where used，就是使用上了where限制。
- 如果是impossible where 表示用不着where，一般就是没查出来啥。
- 出现using index就说明我们的索引是生效的。

### 总结

好了，索引的知识点就介绍到这了，最后总结一下索引的注意事项吧。

1、索引要根据表数据的使用情况来创建，不能创建太多，一般一张表不建议超过6个索引字段

2、好刀要用在刀刃上，经常用于查询，没多少重复数据，搜索行数不超过表数据量4%的字段用索引的效果比较好

3、创建联合索引要注意最左匹配原则，切记，**最左边的字段是必传字段**，这点我他妈就吃过大亏

4、查询语句要用explain执行计划来查看性能。